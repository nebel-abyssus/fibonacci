Быстрое нахождение чисел Фибоначчи.

Многие из тех, кто только приступает к изучению динамического программирования, с одной из первых, сталкиваются с задачей о кузнечике.

На координатном луче, в точке с координатой 1 находится кузнечик. Этот кузнечик может прыгать только вперёд на расстояние 1 либо 2. Сколькими способами он может добраться до точки с координатой n?
Формула для решения этой задачи выводится достаточно просто.
Понятно, что до точки с координатой 0 кузнечик допрыгнуть не может - двигаться назад он не умеет. Способов попасть в эту точку 0. Попасть в точку с координатой 1, в которой он изначально находится, кузнечик может ровно одним способом - оставаться на месте. В любую другую точку с координатой n, кузнечик может добраться либо из точки с координатой n-1, либо из точки с координатой n-2. Соответственно, количество способов которыми он может достичь точки с координатой n равно сумме количеств способов которыми он может достичь точек с координатами n-1, и n-2. Иными словами, если функция f(n) вычисляет количество способов имеющихся у кузнечика чтобы попасть в точку n, то f(n) = f(n-1) + f(n-2).

Другая задача. В начале первого месяца вы получаете пару новорождённых кроликов. Через месяц, эти кролики повзрослеют. Начиная с третьего месяца и далее они будут стабильно давать приплод - ещё одну пару новорождённых кроликов. Таким образом, каждая появившаяся пара кроликов, начиная с двух месяцев после своего появления каждый месяц порождает ещё пару кроликов. Количество кроликов никогда не уменьшается - кролики не болеют и не умирают. Задача: рассчитать какое количество пар кроликов будет у вас, на n-й месяц.
Формула для решения этой задачи, совпадает с формулой, полученной нами в задаче о кузнечике - f(n) = f(n-1) + f(n-2). Вполне очевидно, что каждый месяц к тому количеству кроликов, что было у вас в прошлом месяце прибавляется приплод, от тех кроликов которые у вас были два месяца назад, так как все они к этому моменту уже достаточно повзрослели, чтобы начать активно размножаться.
К счастью, у реальных кроликов несколько иные характеристики, иначе всего лишь через 8 лет (https://xkcd.com/605/), после появления первой пары кроликов, вся поверхность планеты была бы покрыта почти 100 километровым плотным слоем кроличьих тушек.

Для решения обеих задач используется одна и та же формула: f(n) = f(n-1) + f(n-2). Это формула чисел последовательности Фибоначчи. Эта последовательность начинается с элемента под номером 0 и значением 0. За ним следует элемент под номером 1 и значением 1. Значения всех остальных элементов вычисляются согласно приведённой формуле - значение каждого из элементов равно сумме значений двух предыдущих.

Для неотрицательных номеров элементов значения принимают следующий вид:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, ...

Однако, из формулы f(n) = f(n-1) + f(n-2) вытекает, что f(n-2) = f(n) - f(n-1). Зная это, мы можем определить значения элементов последовательности и с отрицательными номерами. Так, элемент под номером -1 имеет значение 1, элемент под номером -2 - значение -1. Мы можем представить общий вид вот так:
..., -377, 233, -144, 89, -55, 34, -21, 13, -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...

Несложно заметить, что значения элементов с отрицательными номерами, являются практически зеркальным отражением значений элементов с положительными номерами, с тем исключением, что элементы под чётными номерами имеют противоположный знак. Мы можем выразить это следующей формулой f(-n) = (-1)^(n+1)f(n). Благодаря данной формуле мы легко можем получить значение элемента под тем же номером с противоположным знаком. Доказательство корректности этой формулы оставляю в качестве небольшого упражнения читателям.

Теперь перейдём к задаче вычисления числа Фибоначчи со сколько-нибудь большим положительным номером. Скажем, 10000000.

Прежде чем приступать к решению, напишем несколько вспомогательных методов.

package fibonacci;

import java.math.BigInteger;

/**
 * Нахождение чисел Фибоначчи.
 * <p>Класс предоставляет статический метод, для нахождения чисел Фибоначчи.</p>
 */
public class Fibonacci {

// static methods

	/**
	 * Точка входа в приложение.
	 * <p>Метод, предполагая, что начальным аргументом запуска указан номер желаемого числа Фибоначчи, вычисляет и выводит его в стандартный вывод.</p>
	 * @param args Набор аргументов запуска.
	 * @throws NullPointerException Если набор аргументов запуска не существует.
	 * @throws ArrayIndexOutOfBoundsException Если набор аргументов запуска пуст.
	 * @throws NumberFormatException Если начальный аргумент запуска не является строкой, содержащей запись целого числа.
	 * @throws IllegalArgumentException Если в качестве начального аргумента запуска указанно значение {@link Integer#MIN_VALUE}.
	 */
	public static void main (
		final String... args
	) { // method body
		final int n = Integer.parseInt(args[0]);
		System.out.println(fib(n));
	} // main()

	/**
	 * Число Фибоначчи под указанным номером.
	 * <p>Метод вычисляет и возвращает число Фибоначчи под указанным номером. Номер может быть как положительным, так и отрицательным.</p>
	 * @param n Номер числа в последовательности. Не должен являться {@link Integer#MIN_VALUE}.
	 * @return Выбранное число Фибоначчи.
	 * @throws IllegalArgumentException Если указанный номер равен {@link Integer#MIN_VALUE}.
	 */
	public static BigInteger fib (
		final int n
	) { // method body
		if (n == Integer.MIN_VALUE) throw new IllegalArgumentException();
		BigInteger answer = null; // Здесь вычисляем абсолютное значение ответа, обратившись к одному из методов.
		if ((n < 0) && (n % 2 == 0)) {
			answer = answer.negate();
		} // if
		return answer;
	} // fib()

// constructors

	/**
	 * Конструктор, предотвращающий создание экземпляров класса.
	 * <p>Конструктор объявлен с единственной целью - предотвратить создание экземпляров класса.</p>
	 * @throws NoSuchMethodError При любом обращении к данному конструктору.
	 */
	private Fibonacci (
	) { // method body
		throw new NoSuchMethodError();
	} // Fibonacci()

} // Fibonacci

Рекурсия.

Мы можем напрямую воспользоваться формулой f(n) = f(n-1) + f(n-2), и выразить функцию вычисления рекурсивно.

На языке Scheme это будет выглядеть так:

(define (fib n)
        ((if (and (negative? n) (even? n))
	     -
	     +) (fib-naive (abs n))))

(define (fib-naive n)
        (cond ((= n 0) 0)
	      ((= n 1) 1)
	      (else (+ (fib (- n 2)) (fib (- n 1))))))

На Java можно выразиться следующим образом:

/**
 * Рекурсивное нахождение чисел Фибоначчи.
 * <p>Метод реализует рекурсивный алгоритм нахождения чисел Фибоначчи.</p>
 * @param n Номер числа в последовательности. Если номер отрицателен, то поведение метода не определено.
 * @return Значение выбранного числа Фибоначчи.
 */
private static BigInteger fibNaive (
	final int n
) { // method body
	return switch (n) {
		case 0 -> BigInteger.ZERO;
		case 1 -> BigInteger.ONE;
		default -> fibNaive(n-1).add(fibNaive(n-2));
	}; // switch
} // fibNaive()

Однако, так как рекурсия требует многократного повторного вычисления одних и тех же значений, такой подход является крайне неэффективным, хотя и позволяет получить правильный результат. Но, по причине неэффективности, о сколько-нибудь больших номерах чисел в последовательности речи не идёт. Уже запрос 45-го числа Фибоначчи, заставляет машину задуматься на заметное время, что делает нашу цель - 10000000-е число последовательности, практически недостижимым.

Итеративный подход.

Мы могли бы значительно сократить количество вычислений, воспользовавшись динамическим программированием. Например просто сохраняя значения уже вычисленных элементов последовательности в массиве, и используя их повторно при рекурсивных запросах. Это так называемая "ленивая динамика". Можно заметить, что в процессе рекурсивные вызовы всегда доходят до нулевого элемента, и таким образом используются значения всех элементов вплоть до целевого. Это позволило бы заменить рекурсию на последовательное заполнение массива вычисленных элементов. Но в процессе написания такого кода, стала бы очевидной вещь, явным образом проистекающая из формулы чисел. Давайте вспомним эту формулу:

f(n) = f(n-2) + f(n-1);

Для получения значения любого из элементов нам нужны значения только двух элементов предшествующих целевому, окружающих его, либо следующих за ним, но не остальные. В сущности, зная значения только любых двух смежных элементов последовательности, мы можем, постепенно продвигаясь в одном из направлений, узнать значение любого другого из элементов последовательности.

Так, зная значения нулевого и первого элементов последовательности, мы можем получить значение второго. Зная значения первого и второго, получаем значение третьего, и так далее.

Давайте выразим всё это в коде, для упрощения реализации начиная с пары минус первого и нулевого элементов.

На Scheme можем выразиться так:

(define (fib n)
        ((if (and (negative? n) (even? n))
	     -
	     +) (fib-iter 1 0 (abs n))))

(define (fib-iter prev cur n)
        (cond ((zero? n) cur)
	      (else (fib-iter cur (+ prev cur) (- n 1)))))

А на Java - так:

/**
 * Последовательное нахождение чисел Фибоначчи.
 * <p>Метод реализует итеративный алгоритм нахождения чисел Фибоначчи.</p>
 * @param n Номер числа в последовательности. Если номер отрицателен, то поведение метода не определено.
 * @return Значение выбранного числа Фибоначчи.
 */
private static BigInteger fibIter (
	final int n
) { // method body
	BigInteger prev = BigInteger.ONE;
	BigInteger cur = BigInteger.ZERO;
	for (int i = n; i > 0; i--) {
		final BigInteger next = cur.add(prev);
		prev = cur;
		cur = next;
	} // for
	return cur;
} // fibIter()

Теперь вычисления происходят несравненно быстрее, так как количество операций линейное. Вычислительная сложность алгоритма O(n). Для вычисления числа Фибоначчи с номером 1000000 придётся немного подождать, но оно стало достижимо. Наша цель - число Фибоначчи с номером 10000000, тоже достижима для этого алгоритма, но из-за большого числа сложений действительно больших чисел, ждать придётся достаточно времени, для того чтобы хватило не спеша выпить чашечку кофе. Хотелось бы уменьшить это время.

Задача о быстром умножении.

Для того, чтобы понять как мы можем находить числа Фибоначчи быстрее, рассмотрим следующую задачу:

Предположим, у нас имеется некий числовой тип данных, для значений которого определена только операция сложения. А нам нужно умножить значение этого типа a на не отрицательный, целый скаляр n.

Для начала, мы можем вспомнить, что операция умножения - это многократное повторение операции сложения. Так mul(a, n) = a + a + a + ... + a, где значение a повторяется n раз.

Операция сложения, может быть выражена через рекурсию mul(a, n) = a + mul(a, n-1), что на Scheme можно высказать так:

(define (mul a n)
        (cond ((zero? n) 0)
	      (else (+ a (mul a (- n 1))))))

Мы можем отказаться от использования рекурсии, заменив её итерациями. Это вытекает из формулы mul(a, n) = mul(a, n-1) + a, если предположить, что к моменту совершения данного шага операции значение mul(a, n-1) уже вычислено. Выразим этот подход на Scheme:

(define (mul a n)
        (mul-iter a 0 n))

(define (mul-iter val accum count)
        (cond ((zero? count) accum)
	      (else (mul-iter val (+ accum val) (- count 1)))))

Вычислительная сложность обоих этих походов, в данной задаче O(n), однако итеративный подход потребляет константное количество памяти, тогда как рекурсивному требуется O(n) дополнительной памяти для хранения промежуточных результатов.

Мы можем улучшить вычислительную сложность до O(log(n)) если вспомним, как значения скалярного числа n вычисляется из его записи в двоичной системе счисления. К примеру число 140 в двоичной системе записывается как 10001100. Значение числа из этой записи получается суммированием произведений значения каждой из цифр, на значение единиц её разряда. В случае числа 140 это выглядит как 128*1 + 64*0 + 32*0 + 16*0 + 8*1 + 4*1 + 2*0 + 1*0 = 128 + 8 + 4 = 140. Таким образом, если значение a умножается на скаляр 140, мы можем выразить это, как a*140 = a*128 + a*8 + a*4. Теперь вспомним, что степени двойки, это число 2 умноженное само на себя несколько раз. Так 128 = 2*2*2*2*2*2*2, 8 = 2*2*2 и 4 = 2*2. Получается, что выражение a*128 + a*8 + a*4 эквивалентно выражению (((((((a*2)*2)*2)*2)*2)*2)*2) + (((a*2)*2)*2) + ((a*2)*2). Используя это, а так же то, что операцию удвоения можно представить как сложение числа с самим собой, мы можем получить алгоритм умножения, работающий за логарифмическое время. Запишем его на языке Scheme:

(define (mul a n)
        (quickMul a 0 n))

(define (quickMul val accum count)
        (cond ((zero? count) accum)
	      ((even? count) (quickMul (double val) accum (/ count 2)))
	      (else (quickMul val (+ accum val) (- count 1)))))

(define (double a)
        (+ a a))

Заметьте, что для значений того же типа, что и a, в этом алгоритме используется только операция сложения, а вычислительная сложность улучшена до логарифмической, при константном потреблении памяти.
