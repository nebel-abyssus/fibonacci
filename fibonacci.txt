Быстрое нахождение чисел Фибоначчи.

Многие из тех, кто только приступает к изучению динамического программирования, с одной из первых, сталкиваются с задачей о кузнечике.

На координатном луче, в точке с координатой 1 находится кузнечик. Этот кузнечик может прыгать только вперёд на расстояние 1 либо 2. Сколькими способами он может добраться до точки с координатой n?
Формула для решения этой задачи выводится достаточно просто.
Понятно, что до точки с координатой 0 кузнечик допрыгнуть не может - двигаться назад он не умеет. Способов попасть в эту точку 0. Попасть в точку с координатой 1, в которой он изначально находится, кузнечик может ровно одним способом - оставаться на месте. В любую другую точку с координатой n, кузнечик может добраться либо из точки с координатой n-1, либо из точки с координатой n-2. Соответственно, количество способов которыми он может достичь точки с координатой n равно сумме количеств способов которыми он может достичь точек с координатами n-1, и n-2. Иными словами, если функция f(n) вычисляет количество способов имеющихся у кузнечика чтобы попасть в точку n, то f(n) = f(n-1) + f(n-2).

Другая задача. В начале первого месяца вы получаете пару новорождённых кроликов. Через месяц, эти кролики повзрослеют. Начиная с третьего месяца и далее они будут стабильно давать приплод - ещё одну пару новорождённых кроликов. Таким образом, каждая появившаяся пара кроликов, начиная с двух месяцев после своего появления каждый месяц порождает ещё пару кроликов. Количество кроликов никогда не уменьшается - кролики не болеют и не умирают. Задача: рассчитать какое количество пар кроликов будет у вас, на n-й месяц.
Формула для решения этой задачи, совпадает с формулой, полученной нами в задаче о кузнечике - f(n) = f(n-1) + f(n-2). Вполне очевидно, что каждый месяц к тому количеству кроликов, что было у вас в прошлом месяце прибавляется приплод, от тех кроликов которые у вас были два месяца назад, так как все они к этому моменту уже достаточно повзрослели, чтобы начать активно размножаться.
К счастью, у реальных кроликов несколько иные характеристики, иначе всего лишь через 8 лет (https://xkcd.com/605/), после появления первой пары кроликов, вся поверхность планеты была бы покрыта почти 100 километровым плотным слоем кроличьих тушек.

Для решения обеих задач используется одна и та же формула: f(n) = f(n-1) + f(n-2). Это формула чисел последовательности Фибоначчи. Эта последовательность начинается с элемента под номером 0 и значением 0. За ним следует элемент под номером 1 и значением 1. Значения всех остальных элементов вычисляются согласно приведённой формуле - значение каждого из элементов равно сумме значений двух предыдущих.

Для неотрицательных номеров элементов значения принимают следующий вид:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, ...

Однако, из формулы f(n) = f(n-1) + f(n-2) вытекает, что f(n-2) = f(n) - f(n-1). Зная это, мы можем определить значения элементов последовательности и с отрицательными номерами. Так, элемент под номером -1 имеет значение 1, элемент под номером -2 - значение -1. Мы можем представить общий вид вот так:
..., -377, 233, -144, 89, -55, 34, -21, 13, -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...

Несложно заметить, что значения элементов с отрицательными номерами, являются практически зеркальным отражением значений элементов с положительными номерами, с тем исключением, что элементы под чётными номерами имеют противоположный знак. Мы можем выразить это следующей формулой f(-n) = (-1)^(n+1)f(n). Благодаря данной формуле мы легко можем получить значение элемента под тем же номером с противоположным знаком. Доказательство корректности этой формулы оставляю в качестве небольшого упражнения читателям.

Теперь перейдём к задаче вычисления числа Фибоначчи со сколько-нибудь большим положительным номером. Скажем, 10000000.

Прежде чем приступать к решению, напишем несколько вспомогательных методов.

package fibonacci;

import java.math.BigInteger;

/**
 * Нахождение чисел Фибоначчи.
 * <p>Класс предоставляет статический метод, для нахождения чисел Фибоначчи.</p>
 */
public class Fibonacci {

// static methods

	/**
	 * Точка входа в приложение.
	 * <p>Метод, предполагая, что начальным аргументом запуска указан номер желаемого числа Фибоначчи, вычисляет и выводит его в стандартный вывод.</p>
	 * @param args Набор аргументов запуска.
	 * @throws NullPointerException Если набор аргументов запуска не существует.
	 * @throws ArrayIndexOutOfBoundsException Если набор аргументов запуска пуст.
	 * @throws NumberFormatException Если начальный аргумент запуска не является строкой, содержащей запись целого числа.
	 * @throws IllegalArgumentException Если в качестве начального аргумента запуска указанно значение {@link Integer#MIN_VALUE}.
	 */
	public static void main (
		final String... args
	) { // method body
		final int n = Integer.parseInt(args[0]);
		System.out.println(fib(n));
	} // main()

	/**
	 * Число Фибоначчи под указанным номером.
	 * <p>Метод вычисляет и возвращает число Фибоначчи под указанным номером. Номер может быть как положительным, так и отрицательным.</p>
	 * @param n Номер числа в последовательности. Не должен являться {@link Integer#MIN_VALUE}.
	 * @return Выбранное число Фибоначчи.
	 * @throws IllegalArgumentException Если указанный номер равен {@link Integer#MIN_VALUE}.
	 */
	public static BigInteger fib (
		final int n
	) { // method body
		if (n == Integer.MIN_VALUE) throw new IllegalArgumentException();
		BigInteger answer = null; // Здесь вычисляем абсолютное значение ответа, обратившись к одному из методов.
		if ((n < 0) && (n % 2 == 0)) {
			answer = answer.negate();
		} // if
		return answer;
	} // fib()

// constructors

	/**
	 * Конструктор, предотвращающий создание экземпляров класса.
	 * <p>Конструктор объявлен с единственной целью - предотвратить создание экземпляров класса.</p>
	 * @throws NoSuchMethodError При любом обращении к данному конструктору.
	 */
	private Fibonacci (
	) { // method body
		throw new NoSuchMethodError();
	} // Fibonacci()

} // Fibonacci

Рекурсия.

Мы можем напрямую воспользоваться формулой f(n) = f(n-1) + f(n-2), и выразить функцию вычисления рекурсивно.

На языке Scheme это будет выглядеть так:

(define (fib n)
        ((if (and (negative? n) (even? n))
	     -
	     +) (fib-naive (abs n))))

(define (fib-naive n)
        (cond ((= n 0) 0)
	      ((= n 1) 1)
	      (else (+ (fib (- n 2)) (fib (- n 1))))))

На Java можно выразиться следующим образом:

/**
 * Рекурсивное нахождение чисел Фибоначчи.
 * <p>Метод реализует рекурсивный алгоритм нахождения чисел Фибоначчи.</p>
 * @param n Номер числа в последовательности. Если номер отрицателен, то поведение метода не определено.
 * @return Значение выбранного числа Фибоначчи.
 */
private static BigInteger fibNaive (
	final int n
) { // method body
	return switch (n) {
		case 0 -> BigInteger.ZERO;
		case 1 -> BigInteger.ONE;
		default -> fibNaive(n-1).add(fibNaive(n-2));
	}; // switch
} // fibNaive()

Однако, так как рекурсия требует многократного повторного вычисления одних и тех же значений, такой подход является крайне неэффективным, хотя и позволяет получить правильный результат. Но, по причине неэффективности, о сколько-нибудь больших номерах чисел в последовательности речи не идёт. Уже запрос 45-го числа Фибоначчи, заставляет машину задуматься на заметное время, что делает нашу цель - 10000000-е число последовательности, практически недостижимым.

Итеративный подход.

Мы могли бы значительно сократить количество вычислений, воспользовавшись динамическим программированием. Например просто сохраняя значения уже вычисленных элементов последовательности в массиве, и используя их повторно при рекурсивных запросах. Это так называемая "ленивая динамика". Можно заметить, что в процессе рекурсивные вызовы всегда доходят до нулевого элемента, и таким образом используются значения всех элементов вплоть до целевого. Это позволило бы заменить рекурсию на последовательное заполнение массива вычисленных элементов. Но в процессе написания такого кода, стала бы очевидной вещь, явным образом проистекающая из формулы чисел. Давайте вспомним эту формулу:

f(n) = f(n-2) + f(n-1);

Для получения значения любого из элементов нам нужны значения только двух элементов предшествующих целевому, окружающих его, либо следующих за ним, но не остальные. В сущности, зная значения только любых двух смежных элементов последовательности, мы можем, постепенно продвигаясь в одном из направлений, узнать значение любого другого из элементов последовательности.

Так, зная значения нулевого и первого элементов последовательности, мы можем получить значение второго. Зная значения первого и второго, получаем значение третьего, и так далее.

Давайте выразим всё это в коде, для упрощения реализации начиная с пары минус первого и нулевого элементов.

На Scheme можем выразиться так:

(define (fib n)
        ((if (and (negative? n) (even? n))
	     -
	     +) (fib-iter 1 0 (abs n))))

(define (fib-iter prev cur n)
        (cond ((zero? n) cur)
	      (else (fib-iter cur (+ prev cur) (- n 1)))))

А на Java - так:

/**
 * Последовательное нахождение чисел Фибоначчи.
 * <p>Метод реализует итеративный алгоритм нахождения чисел Фибоначчи.</p>
 * @param n Номер числа в последовательности. Если номер отрицателен, то поведение метода не определено.
 * @return Значение выбранного числа Фибоначчи.
 */
private static BigInteger fibIter (
	final int n
) { // method body
	BigInteger prev = BigInteger.ONE;
	BigInteger cur = BigInteger.ZERO;
	for (int i = n; i > 0; i--) {
		final BigInteger next = cur.add(prev);
		prev = cur;
		cur = next;
	} // for
	return cur;
} // fibIter()

Теперь вычисления происходят несравненно быстрее, так как количество операций линейное. Вычислительная сложность алгоритма O(n). Для вычисления числа Фибоначчи с номером 1000000 придётся немного подождать, но оно стало достижимо. Наша цель - число Фибоначчи с номером 10000000, тоже достижима для этого алгоритма, но из-за большого числа сложений действительно больших чисел, ждать придётся достаточно времени, для того чтобы хватило не спеша выпить чашечку кофе. Хотелось бы уменьшить это время.
